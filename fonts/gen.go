// +build ignore

// This program generates fonts It can be invoked by running
// go generate
package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"text/template"
)

type Font struct {
	Name  string
	Meta  map[string]string
	Chars map[int][]int
}

func convertHexValues(values []string) ([]int, error) {
	results := make([]int, len(values))
	for i, txt := range values {
		val, err := strconv.ParseInt(txt, 16, 64)
		if err != nil {
			return nil, err
		}
		results[i] = int(val)
	}
	return results, nil
}

func LoadFontFile(path string) (*Font, error) {

	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	// Regex pattern captures "key: value" pair from the content.
	metaReg := regexp.MustCompile(`^(\w+): (.*?)$`)

	font := &Font{}
	font.Name = filepath.Base(path)
	font.Meta = make(map[string]string, 0)
	font.Chars = make(map[int][]int, 0)

	// read line by line
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()

		// meta data
		// TODO load character size (e.g. "Size: 5 x 7")
		matches := metaReg.FindSubmatch([]byte(line))
		if len(matches) > 0 {
			key := string(matches[1])
			font.Meta[key] = string(matches[2])
			continue
		}

		// character line
		// example: "41 A 04 0a 02 02 02 03 00"
		values := strings.Split(strings.TrimSpace(line), " ")
		if len(values) == 9 {
			fmt.Printf("%q\n", values)
			key, err := strconv.ParseInt(values[0], 16, 64)
			if err != nil {
				return nil, err
			}
			val, err := convertHexValues(values[2:])
			if err != nil {
				return nil, err
			}
			font.Chars[int(key)] = val
			continue
		}

	}

	if err := scanner.Err(); err != nil {
		return font, err
	}

	return font, nil
}

func WriteFontFile(font Font, path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()
	return packageTemplate.Execute(f, font)
}

func die(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

func main() {

	patterns := os.Args[1:]

	for _, pattern := range patterns {
		if files, err := filepath.Glob(pattern); err == nil {
			fmt.Println(files)
			for _, file := range files {
				fmt.Println(file)
				font, err := LoadFontFile(file)
				if err != nil {
					die(err)
				}
				fname := fmt.Sprintf("%s.go", file)
				err = WriteFontFile(*font, fname)
				if err != nil {
					die(err)
				}
			}
		}
	}

}

var packageTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was automatically generated
package fonts

{{ range $key, $val := .Meta }}
// {{ $key }} : {{ $val }}
{{- end }}

var font_{{ .Meta.Name }} Font = Font{

	Name: "{{ .Meta.Name }}",
	Chars: map[int][]int{
		{{ range $chr, $val := .Chars }}
		0x{{ printf "%x" $chr }}: { 
			{{- range $val -}}
				0x{{ printf "%x" . }},
			{{- end -}} },
		{{- end -}}
	},
}

`))
