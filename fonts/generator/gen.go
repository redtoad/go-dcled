// This program generates fonts. It can be invoked by running
// go generate
package main

import (
	"bufio"
	"bytes"
	"encoding/hex"
	"errors"
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"text/template"

	"github.com/iancoleman/strcase"
	"github.com/redtoad/go-dcled/fonts"
)

var (
	ErrInvalidSize = errors.New("invalid character size specified")
	ErrNoSize      = errors.New("no character size specified")
)

// convertToInt converts a list of strings into a list on ints.
func convertToInt(txt ...string) ([]int, error) {
	fmt.Printf("convertToInt: %v\n", txt)
	numbers := make([]int, len(txt))
	for i, t := range txt {
		fmt.Printf("i: %v, t: %#v\n", i, t)
		val, err := strconv.Atoi(strings.TrimSpace(t))
		if err != nil {
			return numbers, err
		}
		numbers[i] = val
	}
	return numbers, nil
}

// LoadFontFile loads a Font object from a .dlf file.
func LoadFontFile(path string) (*fonts.Font, error) {

	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	// Regex pattern captures "key: value" pair from the content.
	metaReg := regexp.MustCompile(`^(\w+): (.*?)$`)

	font := &fonts.Font{}
	font.Meta = make(map[string]string)
	font.Chars = make([][]byte, 0)

	// read line by line
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()

		// meta data
		// example: "Size: 5 x 7"
		matches := metaReg.FindSubmatch([]byte(line))
		if len(matches) > 0 {
			key := string(matches[1])
			font.Meta[key] = string(matches[2])
			continue
		}

		// character line
		// example: "41 A 04 0a 02 02 02 03 00"
		values := strings.ReplaceAll(strings.TrimSpace(line), " ", "")
		if len(values) == 2+1+7*2 {
			val, err := hex.DecodeString(values[3:])
			if err != nil {
				return nil, err
			}

			font.Chars = append(font.Chars, val)
			continue
		}

	}

	// Now that we have loaded everything, we can use the
	// metadata from the file (if present).

	if name, ok := font.Meta["Name"]; ok {
		font.Name = name
	} else {
		font.Name = filepath.Base(path)
	}

	if size, ok := font.Meta["Size"]; ok {
		parts := strings.Split(size, "x")
		fmt.Printf("parts: %v\n", parts)
		if len(parts) != 2 {
			return font, ErrInvalidSize
		}
		sizes, err2 := convertToInt(parts...)
		fmt.Printf("sizes: %v\n", sizes)
		if err2 != nil {
			return font, ErrInvalidSize
		}

		font.CharWidth = sizes[0]
		font.CharHeight = sizes[1]

	} else {
		return font, ErrNoSize
	}

	if err := scanner.Err(); err != nil {
		return font, err
	}

	return font, nil
}

// WriteFontFile creates a Go file with a font declaration.
func WriteFontFile(font fonts.Font, path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	var tpl bytes.Buffer
	err = packageTemplate.Execute(&tpl, font)
	if err != nil {
		return err
	}

	// format code with go fmt before saving to file
	content, err := format.Source(tpl.Bytes())
	if err != nil {
		return err
	}

	_, err = f.Write(content)
	return err
}

func die(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

func main() {

	patterns := os.Args[1:]

	fmt.Println("Generating fonts...")
	for _, pattern := range patterns {
		if files, err := filepath.Glob(pattern); err == nil {
			for _, file := range files {
				fname := fmt.Sprintf("font_%s.go", file)
				fmt.Printf("%s -> %s\n", file, fname)
				font, err := LoadFontFile(file)
				if err != nil {
					die(err)
				}

				err = WriteFontFile(*font, fname)
				if err != nil {
					die(err)
				}
			}
		}
	}

}

var funcMap = template.FuncMap{
	"ToUpper":     strings.ToUpper,
	"ToCamelCase": strcase.ToCamel,
}

var packageTemplate = template.Must(template.New("").Funcs(funcMap).Parse(`
// Code automatically generated by go generate; DO NOT EDIT.

package fonts

{{ range $key, $val := .Meta }}
// {{ $key }} : {{ $val }}
{{- end }}

var {{ .Meta.Name | ToCamelCase }}Font Font = Font{

	Name: "{{ .Meta.Name }}",
	CharWidth: {{ .CharWidth }},
	CharHeight: {{ .CharHeight }},
	Chars: [][]byte{
		{{ range $chr, $val := .Chars }}
		{ 
			{{- range $val -}}
				0x{{ printf "%x" . }}, 
			{{- end -}} 
		},  // {{ print $chr }}: {{ if (ge $chr 32) }}{{ printf "%c" $chr }}{{end}}
		{{- end }}

	},
}

`))
