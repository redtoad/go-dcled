// This program generates fonts It can be invoked by running
// go generate
package main

import (
	"bufio"
	"bytes"
	"encoding/hex"
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"

	"github.com/redtoad/dcled/fonts"
)

func LoadFontFile(path string) (*fonts.Font, error) {

	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	// Regex pattern captures "key: value" pair from the content.
	metaReg := regexp.MustCompile(`^(\w+): (.*?)$`)

	font := &Font{}
	font.Name = filepath.Base(path)
	font.Meta = make(map[string]string, 0)
	font.Chars = make(map[int][]byte, 0)

	// read line by line
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()

		// meta data
		// TODO load character size (e.g. "Size: 5 x 7")
		matches := metaReg.FindSubmatch([]byte(line))
		if len(matches) > 0 {
			key := string(matches[1])
			font.Meta[key] = string(matches[2])
			continue
		}

		// character line
		// example: "41 A 04 0a 02 02 02 03 00"
		values := strings.ReplaceAll(strings.TrimSpace(line), " ", "")
		if len(values) == 2+1+7*2 {
			fmt.Printf("%q\n",
				values)
			key, err := hex.DecodeString(values[0:2])
			if err != nil {
				panic(err)
				return nil, err
			}

			val, err := hex.DecodeString(values[3:])
			if err != nil {
				return nil, err
			}

			font.Chars[int(key[0])] = val
			continue
		}

	}

	if err := scanner.Err(); err != nil {
		return font, err
	}

	return font, nil
}

func WriteFontFile(font Font, path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	var tpl bytes.Buffer
	err = packageTemplate.Execute(&tpl, font)
	if err != nil {
		return err
	}

	// format code with go fmt before saving to file
	content, err := format.Source(tpl.Bytes())
	if err != nil {
		return err
	}

	_, err = f.Write(content)
	return err
}

func die(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

func main() {

	patterns := os.Args[1:]

	for _, pattern := range patterns {
		if files, err := filepath.Glob(pattern); err == nil {
			fmt.Println(files)
			for _, file := range files {
				fmt.Println(file)
				font, err := LoadFontFile(file)
				if err != nil {
					die(err)
				}
				fname := fmt.Sprintf("%s.go", file)
				err = WriteFontFile(*font, fname)
				if err != nil {
					die(err)
				}
			}
		}
	}

}

var packageTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was automatically generated
package main

{{ range $key, $val := .Meta }}
// {{ $key }} : {{ $val }}
{{- end }}

var Font_{{ .Meta.Name }} Font = Font{

	Name: "{{ .Meta.Name }}",
	Chars: map[int][]byte{
		{{ range $chr, $val := .Chars }}
		0x{{ printf "%x" $chr }}: { 
			{{- range $val -}}
				0x{{ printf "%x" . }},
			{{- end -}} },
		{{- end -}}
	},
}

`))
